# Imports
import argparse
import json
import logging
import os
import pandas as pd
import sys

logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from collections import OrderedDict
from datetime import datetime
from mudscope import MUDGenUtils
from mudscope.Constants import *
from mudscope.MRTFeed import MRTFeed
from mudscope.MRTADashboard import MRTADashboard
from mudscope.VMUDEnforcer import Virtual_MUD_enforcer
from mudscope.MRTACharacterizator import MRTACharacterizator
from mudscope.MRTAPairClustersProcessor import MRTAPairClustersProcessor
from mudscope import device_mrt_pcaps_to_csv as mrttocsv
from pathlib import Path
from scapy.all import *
from typing import Iterable, Union

################################################################################
#                               Argument parsing                               #
################################################################################

def parse_args(arguments=None) -> argparse.Namespace:
	"""Parse arguments for running MUDscope.
	
		Returns
		-------
		args : argparse.Namespace
			Parsed arguments.
		"""
	# Create argument parser
	parser = argparse.ArgumentParser(
		description = "MUDscope - Stepping out of the MUD: Contextual threat "
		              "information for IoT devices with manufacturer-provided "
					  "behaviour profiles."
	)

	########################################################################
	#                       Choose mode of operation                       #
	########################################################################

	subparsers = parser.add_subparsers(
		title       = 'mode',
		description = 'Mode in which to run MUDscope.',
		dest        = 'mode',
		required    = True,
	)

	########################################################################
	#                            Mode = mudgen                             #
	########################################################################

	parser_mudgen = subparsers.add_parser(
		MODE_MUDGEN,
		description = 'Create MUD files from benign network traces.',
		help        = 'Create MUD files from benign network traces.',
	)
	parser_mudgen.add_argument(
		'--config',
		metavar  = '<path>',
		help     = 'path to JSON config file for mudgee MUD generation',
		required = True,
	)

	########################################################################
	#                            Mode = reject                             #
	########################################################################

	parser_reject = subparsers.add_parser(
		MODE_REJECT,
		description = 'Filter MUD rejected traffic from pcap files.',
		help        = 'Filter MUD rejected traffic from pcap files.',
	)
	parser_reject.add_argument(
		'--config',
		metavar  = '<path>',# '<JSON file of MUD config for filtering data>',
		nargs    = '+',
		help     = 'path(s) to JSON config file(s) for MUD enforcement',
		required = True,
	)
	parser_reject.add_argument(
		'--rules',
		metavar  = '<path>',
		help     = 'path to MUD rules CSV file generated by MUDgee',
		required = True,
	)
	parser_reject.add_argument(
		'--output',
		metavar  = '<path>',
		help     = 'path to output directory in which to store results',
		required = True,
	)
	# Optional, if set, limits the number of packets that are processed when rejecting traffic
	parser_reject.add_argument(
		'--limit',
		metavar  = '<int>',
		type     = int,
		help     = 'optional, limits the number of packets processed when rejecting traffic',
		required = False,
	)

	########################################################################
	#                           Mode = netflows                            #
	########################################################################

	parser_netflows = subparsers.add_parser(
		MODE_FLOWS_GENERATION,
		description = 'Transform MRT pcap files to NetFlows.',
		help        = 'Transform MRT pcap files to NetFlows.',
	)
	parser_netflows.add_argument(
		'--input',
		metavar  = '<path>',
		help     = 'path to directory containing MUD-rejected pcap files',
		required = True,
	)
	parser_netflows.add_argument(
		'--output',
		metavar  = '<path>',
		help     = 'path to output directory in which to store NetFlows',
		required = True,
	)

	########################################################################
	#                         Mode = characterize                          #
	########################################################################

	parser_characterize = subparsers.add_parser(
		MODE_CHARACTERIZE,
		description = 'Perform characterization analysis on MRT netflows.',
		help        = 'Perform characterization analysis on MRT netflows.',
	)
	parser_characterize.add_argument(
		'--input',
		nargs    = '+',
		metavar  = '<path>',
		help     = 'path(s) to CSV file(s) containing MRT netflows',
		required = True,
	)
	parser_characterize.add_argument(
		'--metadata',
		metavar  = '<path>',
		help     = 'path to JSON file describing the capture to analyse', # \nIt shall contain at least "device_id" (string), and "deployment_info" (any type as of now) that describes the setting where the device is (e.g., lon, lat, industry_type, ...)
		required = True,
	)

	parser_characterize.add_argument(
		'--dsr',
		metavar  = '<path>',
		help     = f'path to Dataset Scaler Reference (DSR) CSV file',
		required = True,
	)
	parser_characterize.add_argument(
		'--output',
		metavar  = '<path>',
		help     = "output directory in which to store analyzed file(s)",
		required = True,
	)

	########################################################################
	#                           Mode = evolution                           #
	########################################################################

	parser_evolution = subparsers.add_parser(
		MODE_EVOLUTION,
		description = 'Perform evolution analysis on characterization files to produce MRT feeds.',
		help        = 'Perform evolution analysis on characterization files to produce MRT feeds.',
	)
	parser_evolution.add_argument(
		'--input',
		nargs    = '+',
		metavar  = '<path>',
		help     = 'path(s) to file(s) containing JSON characterization files',
		required = True,
	)
	parser_evolution.add_argument(
		'--output',
		metavar  = '<path>',
		help     = "output file in which to store MRT feed",
		required = True,
	)

	########################################################################
	#                             Monitor mode                             #
	########################################################################

	parser_monitor = subparsers.add_parser(
		MODE_MONITOR,
		description = 'Monitor and compare anomalous activities captured in MRT feeds.',
		help        = 'Monitor and compare anomalous activities captured in MRT feeds.',
	)
	
	parser_monitor.add_argument(
		'--config',
		metavar  = '<path>',
		help     = 'monitor config file specifying MRT feeds to compare', #  (JSON list of dev_metadata + csv feed) are taken
		required = True,
	)
	parser_monitor.add_argument(
		'--output',
		metavar  = '<path>',
		help     = 'path to directory in which to write output monitor plots',
		required = True,
	)

	# Return parsed arguments
	return parser.parse_args(arguments)

################################################################################
#                                    Modes                                     #
################################################################################

def mode_mudgen(config: Union[str, Path]) -> None:
	"""Run MUDscope in mudgen mode.

		Generates a MUD profile from a given configuration.
		See example config files for required format.
	
		Parameters
		----------
		config : Union[str, Path]
			Path to config file from which to generate MUD profile.
		"""
	# Get info from MUD config file
	with open(config) as mg_cf:
		mg_data = json.load(mg_cf)
	device_name = mg_data['deviceConfig']['deviceName']
	# Run mudgee
	mudgee_gen_outcome = MUDGenUtils.run_mudgee(config)
	print(f'MUD data to generate with MUDgee from info in config file {config}') 

	if mudgee_gen_outcome == 0:
		print(f'MUD data output in result/{device_name}')
	else:
		raise ValueError('Some error occurred in generating MUD data.')


def mode_reject(
		rules     : Union[str, Path],
		configs   : Iterable[Union[str, Path]],
		outdir    : Union[str, Path],
		pcap_limit: Optional[int] = None,
	) -> None:
	"""Run MUDscope in reject mode.
	
		Applies MUD profile as a filter on given pcap files to create a new
		pcap file with MUD-rejected traffic.
		
		Parameters
		----------
		rules : Union[str, Path]
			Path to csv file containing MUD rules.
			Usually this is generated as an output of the mode_mudgen function.

		configs : Iterable[Union[str, Path]]
			Path to json file containing reject configuration.

		outdir : Union[str, Path]
			Path to output directory in which to store output files

		pcap_limit : Optional[int], default = None
			Optional limit on number of flows to read from given pcap file.
		"""
	########################################################################
	#                                Checks                                #
	########################################################################

	# Check if MUD rules exist
	if not os.path.isfile(rules):
		raise ValueError(
			f'MUD-derived (OpenFlow) rules CSV file <{rules}> not found.'
		)

	########################################################################
	#                                 Run                                  #
	########################################################################

	# Loop over all specified config files
	for config in configs:
		# Check if file exists
		if not os.path.isfile(config):
			raise ValueError(f"Unknown config file: '{config}'")

		# Read reject configuration
		with open(config) as mc_data:
			data = json.load(mc_data)

		# Get PCAP location
		reject_pcap = data['filterPcapLocation']

		# Check if pcap to process exists
		if reject_pcap is not None and not os.path.isfile(reject_pcap):
			raise ValueError(
				f'"{reject_pcap}" does not exist. '
				f'Check --config file key-values {json.dumps(data, indent=4)}'
				f'\n(if null: are you trying to use a MUDgee config file?)'
			)

		# Create MUD enforcer
		v_mud_enf = Virtual_MUD_enforcer(
			device_mac   = data['deviceConfig']['device'],
			device_name  = data['deviceConfig']['deviceName'] ,
			gateway_mac  = data['defaultGatewayConfig']['macAddress'],
			filter_rules = rules,
		)

		# Run virtual MUD enforcer on pcap, for given
		v_mud_enf.enforce_in_pcap(
			pcap_file  = reject_pcap,
			pcap_limit = pcap_limit,
			save_json  = True,
			named_dir  = outdir,
		)


def mode_netflows(
		pcap_dir: Union[str, Path],
		outdir  : Union[str, Path],
	) -> None:
	"""Run MUDscope in netflows mode.
	
		Transforms pcap files of MUD-rejected traffic into NetFlows.
		
		Parameters
		----------
		pcap_dir : Union[str, Path]
			Directory containing pcap files of MUD-rejected traffic.

		outdir : Union[str, Path]
			Output directory in which to store NetFlows.
		"""
	# Check if pcap_dir exists
	if not os.path.isdir(pcap_dir):
		raise ValueError(
			f"Invalid --input argument for mode {MODE_FLOWS_GENERATION}. "
			f"Please enter a valid path to folder "
			"containing pcaps to convert to flows CSV file."
		)

	# Transform MRT to CSV files
	mrttocsv.module_each_pcap_to_complete_csv(
		pcaps_dir = pcap_dir,
		outdir    = outdir,
	)


def mode_characterize(
		targets: Iterable[Union[str, Path]],
		config : Union[str, Path],
		dsr    : Union[str, Path],
		outdir : Union[str, Path],
	) -> None:
	"""Run MUDscope in characterize mode.

		Creates characterization files for given NetFlow files.

		Parameters
		----------
		targets : Iterable[Union[str, Path]]
			Paths to NetFlow files from which to generate characterization
			files.

		config : Union[str, Path]
			Path to characterization configuration file.

		dsr : Union[str, Path]
			Path to dataset scaling reference (DSR) file.

		outdir : Union[str, Path]
			Path to output directory in which to store processed
			characterization files.
		"""
	# Load metadata
	with open(config) as md:
		metadata = json.load(md)

	# Check if metadata is set
	if metadata.get('device_id') is None or metadata.get('deployment_info') is None:
		raise ValueError(
			f"device_id or deployment_info entries missing in "
			f"metadata [ {config} ]"
		)

	# Loop over all given targets
	for target in targets:
		# Initialise characterization constructor
		mrta_characterizator = MRTACharacterizator(
			capture_data = metadata,
			csv_file = target,
			dataset_scaler_gen_reference_path = dsr,
		)
		# Perform characterization
		mrta_characterizator.input_to_characterization_data()

		# Prepare output file
		outfile = Path(outdir) / (Path(target).stem + '.json')
		# Make directory
		outfile.parent.mkdir(parents=True, exist_ok=True)
		# Save to outfile
		mrta_characterizator.save_characterization(outfile)


def mode_evolution(
		characterizations: Iterable[Union[str, Path]],
		outfile: Union[str, Path],
	) -> None:
	"""Run MUDscope in evolution mode.
	
		Generates MRT feeds from given characterization files.

		Parameters
		----------
		characterizations : Iterable[Union[str, Path]]
			Paths to characterization files from which to generate MRT feeds.

		outfile : Union[str, Path]
			Path to output file in which to store MRT feed.
		"""
	# Initialise characterizations
	ordered_characterizations = {}

	# Loop over all files
	for filename in characterizations:
		# Load file as json
		with open(filename, 'r') as file:
			data = json.load(file)
		# Extract timestamp
		start_timestamp = data.get('metadata', {}).get('time_window', [None])[0]

		# Print error if any
		if start_timestamp is None:
			raise ValueError(
				f"Unable to fetch time information from characterization file "
				f"{filename}. Is the JSON format valid?."
			)

		# Convert date to timestamp and store
		ordered_characterizations[filename] = float(
			datetime.timestamp(
			datetime.strptime(start_timestamp, STRFTIME_READABLE_FORMAT)
		))
	
	# Sort dictionary
	ordered_characterizations = OrderedDict(
		sorted(ordered_characterizations.items(), key=lambda item: item[1])
	)
	
	chrono_ch_files = [k for k in ordered_characterizations.keys()]
	
	entries_list = []
	
	for ch1, ch2 in zip(chrono_ch_files, chrono_ch_files[1:]):
		mrta_pcp = MRTAPairClustersProcessor(ch1, ch2)
		mrta_pcp.populate_clusters_shifts_data()
		mrta_pcp.set_transition_characterization_data()

		transition_df = mrta_pcp.get_transition_characterization_data_df_entry()
		mrta_pcp.print_distance_matrix(readable_only=False)
		entries_list.append(transition_df)
	
	df = pd.concat(entries_list, ignore_index=True)

	# Prepare output file
	outfile = Path(outfile)
	# Make directory
	outfile.parent.mkdir(parents=True, exist_ok=True)
	# Save to outfile
	df.to_csv(outfile)
	

def mode_monitor(
		config: Union[str, Path],
		output: Union[str, Path],
	) -> None:
	"""Run MUDscope in monitor mode.

		Generate fluctuation graphs in MRT feeds.
	
		Parameters
		----------
		config : Union[str, Path]
			Path to config file for generating fluctuation graphs.

		output : Union[str, Path]
			Path to output directory in which to store resulting graphs.
		"""

	""" Generate fluctuation graphs """
	# Open configuration
	with open(config) as mrtf_conf:
		mrtf_data = json.load(mrtf_conf)
	mrtf_data_list = mrtf_data['mrtfeeds']
	monitor_features = mrtf_data['features_watch']
	transition_window = mrtf_data['transition_window']
	
	mrt_feeds_list = []
	for l in mrtf_data_list:
		mrt_feeds_list.append(MRTFeed(l['device_metadata'], l['csv_mrt_feed']))

	# Perform monitoring
	mrtadb = MRTADashboard()
	mrtadb.setup(mrt_feeds_list, monitor_features, transition_window)
	mrtadb.detect_anomalies()
	mrtadb.find_matching_anomalies()

	mrtadb.generate_report(
		outdir = output,
	)




def main(arguments=None) -> None:
	"""Run MUDscope, see individual modes for usage."""
	# Parse arguments
	args = parse_args(arguments)

	# Run in given mode
	# Mode mudgen
	if args.mode == MODE_MUDGEN:
		return mode_mudgen(
			config = args.config,
		)
	# Mode reject
	elif args.mode == MODE_REJECT:
		return mode_reject(
			rules      = args.rules,
			configs    = args.config,
			outdir     = args.output,
			pcap_limit = args.limit,
		)
	# Mode netflows
	elif args.mode == MODE_FLOWS_GENERATION:
		return mode_netflows(
			pcap_dir = args.input,
			outdir   = args.output,
		)
	# Mode characterize
	elif args.mode == MODE_CHARACTERIZE:
		return mode_characterize(
			targets = args.input,
			config  = args.metadata,
			dsr     = args.dsr,
			outdir  = args.output,
		)
	# Mode evolution
	elif args.mode == MODE_EVOLUTION:
		return mode_evolution(
			characterizations = args.input,
			outfile           = args.output,
		)
	# Mode monitor
	elif args.mode == MODE_MONITOR:
		return mode_monitor(
			config   = args.config,
			output   = args.output,
		)
	else:
		raise ValueError(f"Unknown mode: {args.mode}")


if __name__ == '__main__':
	main()
